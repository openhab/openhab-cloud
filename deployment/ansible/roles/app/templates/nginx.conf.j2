map $http_upgrade $connection_upgrade {
    default upgrade;
    '' close;
}

# Socket.IO connections from openHAB instances — consistent hash by source IP
# so the same openHAB reconnects to the same Node.js instance
upstream socketapp {
    hash $remote_addr consistent;
{% for i in range(node_instances) %}
    server 127.0.0.1:{{ 3000 + i }};
{% endfor %}
}

# All other traffic — round-robin across all local instances
# Proxy requests use CloudServer cookie affinity (set by the app) to route
# directly to the server holding the openHAB WebSocket connection
upstream app {
{% for i in range(node_instances) %}
    server 127.0.0.1:{{ 3000 + i }};
{% endfor %}
}

# Redirect HTTP to HTTPS
server {
    listen 80 default_server;
    listen [::]:80 default_server;
    server_name {{ domain }} home.{{ domain }};
    return 301 https://$host$request_uri;
}

# Full proxy for home.{{ domain }} — all traffic is proxied to openHAB instances
server {
    listen 443 ssl;
    server_name home.{{ domain }};

    ssl_certificate /etc/letsencrypt/live/{{ domain }}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/{{ domain }}/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 1d;

    charset utf-8;
    client_max_body_size 300m;

    location / {
        set $upstream_server app;
        # If we have a cookie, route directly to the server holding the connection
        if ($http_cookie ~ "CloudServer=(\S+)\%3A(\d+).*") {
            set $upstream_host $1;
            set $upstream_port $2;
            set $upstream_server "${upstream_host}:${upstream_port}";
        }
        proxy_pass http://$upstream_server;
        proxy_redirect off;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;
        # If cookie-targeted server is down, fall back to local round-robin
        error_page 502 503 504 = @fallback;
    }

    location @fallback {
        proxy_pass http://app;
        proxy_redirect off;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;
    }
}

# Main {{ domain }} — Socket.IO, proxied connections, and web UI
server {
    listen 443 ssl;
    server_name {{ domain }};

    ssl_certificate /etc/letsencrypt/live/{{ domain }}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/{{ domain }}/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 1d;

    charset utf-8;
    client_max_body_size 300m;

    # Socket.IO connections from openHAB instances
    location /socket.io {
        proxy_pass http://socketapp;
        proxy_redirect off;
        proxy_http_version 1.1;
        proxy_read_timeout 10m;
        proxy_connect_timeout 10m;
        proxy_send_timeout 10m;
        proxy_set_header Host $host;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
    }

    # Proxied connections from clients — cookie routing with fallback
    location ~ ^/(rest|ws|images|static|rrdchart\.png|chart|openhab\.app|WebApp|CMD|cometVisu|proxy|greent|jquery|classicui|ui|basicui|paperui|doc|start|icon|habmin|remote|habpanel|ifttt/v1/actions/command) {
        set $upstream_server app;
        if ($http_cookie ~ "CloudServer=(\S+)\%3A(\d+).*") {
            set $upstream_host $1;
            set $upstream_port $2;
            set $upstream_server "${upstream_host}:${upstream_port}";
        }
        proxy_pass http://$upstream_server;
        proxy_redirect off;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;
        # If cookie-targeted server is down, fall back to local round-robin
        error_page 502 503 504 = @fallback;
    }

    # All other requests (web UI, account pages, etc.)
    location / {
        proxy_pass http://app;
        proxy_redirect off;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
    }

    location @fallback {
        proxy_pass http://app;
        proxy_redirect off;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;
    }
}
